◦ OPENDIR
Функция opendir() открывает поток каталога, соответствующий каталогу name, и возвращает указатель на этот поток. Поток устанавливается на первой записи в каталоге.  
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция opendir() возвращает указатель на поток каталога или NULL в случае ошибок.  
НАЙДЕННЫЕ ОШИБКИ
EACCES
- доступ запрещен;
EMFILE
- процесс использует слишком много открытых потоков;
ENFILE
- система использует слишком много открытых потоков;
ENOENT
- каталога не существует или name - пустая строка;
ENOMEM
- недостаточно памяти для выполнения операции;
ENOTDIR
- name - это не каталог.


◦ READDIR
Функция readdir() возвращает указатель на следующую запись каталога в структуре dirent, прочитанную из потока каталога. Каталог указан в dir. Функция возвращает NULL по достижении последней записи или если была обнаружена ошибка.
В соответствие с POSIX, структура dirent содержит поле char d_name[] неопределенной длины, с максимальным количеством символов, предшествующих конечному нулевому символу, равным NAME_MAX. Использование других полей отрицательно повлияет на переносимость ваших программ. В POSIX-2001 как расширение XSI описано поле ino_t d_ino. Данные, возвращаемые readdir() могут быть переписаны последующими вызовами readdir() для того же каталожного потока.  

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция readdir() возвращает указатель на структуру dirent или NULL в случае ошибки или по достижении последней записи.  
НАЙДЕННЫЕ ОШИБКИ
EBADF
неверный описатель потока каталога dir.

◦ CLOSEDIR
Функция closedir() закрывает поток, связанный с каталогом dir. Описатель потока dir будет недоступен после вызова этой функции.  
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция closedir() возвращает 0 в случае удачного завершения работы, или -1 при ошибке.  
НАЙДЕННЫЕ ОШИБКИ
EBADF
Неверный описатель потока каталога dir.


◦ STAT && LSTAT
Эти функции возвращают информацию об указанном файле. Для этого не требуется иметь права доступа к файлу, хотя потребуются права поиска во всех каталогах, указанных в полном имени файла.

stat возвращает информацию о файле file_name и заполняет буфер buf. lstat идентична stat, но в случае символьных сылок она возвращает информацию о самой ссылке, а не о файле, на который она указывает. fstat идентична stat, только возвращается информация об открытом файле, на который указывает filedes (возвращаемый open(2)), а не о file_name.

Все эти функции возвращают структуру stat, которая содержит следующие поля:

struct stat {
    dev_t         st_dev;      /* устройство */
    ino_t         st_ino;      /* inode */
    mode_t        st_mode;     /* режим доступа */
    nlink_t       st_nlink;    /* количество жестких ссылок */
    uid_t         st_uid;      /* идентификатор пользователя-владельца */
    gid_t         st_gid;      /* идентификатор группы-владельца */
    dev_t         st_rdev;     /* тип устройства */
                               /* (если это устройство) */
    off_t         st_size;     /* общий размер в байтах */
    blksize_t     st_blksize;  /* размер блока ввода-вывода */
                               /* в файловой системе */
    blkcnt_t      st_blocks;   /* количество выделенных блоков */
    time_t        st_atime;    /* время последнего доступа */
    time_t        st_mtime;    /* время последней модификации */
    time_t        st_ctime;    /* время последнего изменения */
};
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
В случае успеха возвращается ноль. При ошибке возвращается -1, а переменной errno присваивается номер ошибки.  
НАЙДЕННЫЕ ОШИБКИ
EBADF
Неверный файловый описатель filedes.
ENOENT
Компонент полного имени файла file_name не существует или полное имя является пустой строкой.
ENOTDIR
Компонент пути не является каталогом.
ELOOP
При поиске файла встретилось слишком много символьных ссылок.
EFAULT
Некорректный адрес.
EACCES
Запрещен доступ.
ENOMEM
Недостаточно памяти в системе.
ENAMETOOLONG
Слишком длинное название файла.


◦ GETPWUID
Функция getpwnam() возвращает указатель на структуру, содержащую поля строки из файла /etc/passwd для записи, совпадающей с именем пользователя name.
Функция getpwuid() возвращает указатель на структуру, содержащую поля строки из файла /etc/passwd для записи, совпадающей с идентификатором пользователя uid.

Структура passwd определена в файле <pwd.h> следующим образом:


struct passwd {
        char    *pw_name;       /* имя пользователя */
        char    *pw_passwd;     /* пароль пользователя */
        uid_t   pw_uid;         /* id пользователя */
        gid_t   pw_gid;         /* id группы */
        char    *pw_gecos;      /* настоящее имя */
        char    *pw_dir;        /* домашний каталог */
        char    *pw_shell;      /* программа-оболочка */
};

 
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функции getpwnam() и getpwuid() возвращают указатель на структуру passwd или NULL, если искомая запись не найдена или произошла ошибка.  
НАЙДЕННЫЕ ОШИБКИ
0 или ENOENT или ESRCH или EBADF или EPERM или ...
Заданное name или gid не найдены.
ENOMEM
Недостаточно памяти для размещения структуры passwd.
EIO
Ошибка ввода/вывода.
EINTR
Был пойман сигнал.
EMFILE
В вызывающем процессе достигнуто максимальное число (OPEN_MAX) файлов.
ENFILE
В системе уже достигнуто максимальное число файлов.


◦ GETGRID
Функция getgrnam() возвращает указатель на структуру, содержащую информацию из файла /etc/group о группе, имя которой совпадает с name.
Функция getgrgid() возвращает указатель на структуру, содержащую информацию из файла /etc/group о группе, идентификатор которой совпадает с gid.

Структура group определена в <grp.h> следующим образом:


struct group {
        char    *gr_name;        /* название группы */
        char    *gr_passwd;      /* пароль группы */
        gid_t   gr_gid;          /* идентификатор группы */
        char    **gr_mem;        /* члены группы */
};

 
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функции getgrnam() и getgrgid() возвращают указатель на структуру с информацией о группе или NULL, если соответствующий элемент не найден или если произошла ошибка. При ошибках переменная errno соответственно устанавливается.
Возвращаемое значение может указывать на статическую область, но может быть переопределено последующимим вызовами.  

НАЙДЕННЫЕ ОШИБКИ
0 или ENOENT или ESRCH или EBADF или EPERM или ...
Заданное name или gid не найдено.
ENOMEM
Недостаточно памяти.
EIO
Ошибка ввода/вывода.
EINTR
Был пойман сигнал.
EMFILE
В вызывающем процессе достигнуто максимальное число (OPEN_MAX) файлов.
ENFILE
В системе уже достигнуто максимальное число файлов.


◦ LISTXATTR
Расширенные атрибуты являются парами name:value ассоциированными с записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются расширениями к обычным атрибутам, ассоциированными со всеми записями inode в системе (например, данные stat(2)). Полный обзор концепции расширенных атрибутов можно посмотреть в attr(5).
listxattr получает список list названий расширенных атрибутов, ассоциированных с заданным путем path в файловой системе. Список является набором названий (заканчивающихся NULL) один за одним. Названия расширенных атрибутов, к которым вызывающий процесс не может иметь доступ, могут быть исключены из списка. Возвращается длина списка list названий атрибутов.

llistxattr идентично listxattr, за исключением случая символьной ссылки, где список названий расширенных атрибутов ассоциируется с самой полученной ссылкой, а не с файлом, на который они ссылаются.

flistxattr идентично listxattr, только открываемый файл, на который указывает filedes (возвращаемый от open(2)) рассматривается вместо path.

Расширенный атрибут name является просто строкой, заканчивающейся NULL. Имя включает префикс пространства имен - их может быть несколько, разрозненные пространства ассоциируются с разными записями inode.

Пустой буфер с размером size, равным нулю может быть передан этим вызовам для возврата текущего размера указанного расширенного атрибута, что может быть использовано для определения размера буфера, который существенно больше, так как должен содержать значения, ассоцированные с расширенными атрибутами.
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
При успешном завершении работы возвращается положительное число, обозначая размер списка названий расширенных атрибутов. При ошибках возвращается -1 и errno устанавливается соответственно ошибке.
Если размер size буфера значения value слишком мал для хранения результата, то errno устанавливается в ERANGE.

Если расширенные атрибуты не поддерживаются файловой системой или отключены, то errno устанавливается в ENOTSUP.

Ошибки, документированные для системного вызова stat(2) также применимы и тут.


◦ GETXATTR
Расширенные атрибуты являются парами name:value ассоциированными с записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются расширениями к обычным атрибутам, ассоциированными со всеми записями inode в системе (например, данные stat(2)). Полный обзор концепции расширенных атрибутов можно посмотреть в attr(5).
getxattr получает значение value расширенного атрибута, идентифицированного по имени name и ассоциированного с указанным путем path в файловой системе. Длина атрибута value возвращается.

lgetxattr идентично getxattr, за исключением случаев символьной ссылки, когда рассматривается ссылка сама по себе, а не тот файл, на который она указывает.

fgetxattr идентично getxattr, только открываемый файл, на который указывает filedes (возвращаемый от open(2)) рассматривается вместо path.

Расширенный атрибут name является просто строкой, заканчивающейся NULL. Имя включает префикс пространства имен - их может быть несколько, разрозненные пространства ассоциируются с разными записями inode. Значением расширенного атрибута является произвольный кусок текстовых или двоичных данных определенной длины.

Пустой буфер с размером size, равным нулю может быть передан этим вызовам для возврата текущего размера указанного расширенного атрибута, что может быть использовано для определения размера буфера, который существенно больше, так как должен содержать значения, ассоцированные с расширенными атрибутами.

Интерфейс разработан так, чтобы можно было узнать размеры начального буфера и для дальнейшего увеличения буферов, когда возвращаемое значение указывает, что переданный буфер был слишком мал.  

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
При успешном завершении работы возвращается положительное число, обозначая размер расширенного атрибута. При ошибках возвращается -1 и errno устанавливается соответственно ошибке.
Если именованный атрибут не существует или если процесс не имеет прав доступа к этому атрибуту, то errno устанавливается в ENOATTR.

Если размер size буфера значения value слишком мал для хранения результата, то errno устанавливается в ERANGE.

Если расширенные атрибуты не поддерживаются файловой системой или отключены, то errno устанавливается в ENOTSUP.

Ошибки, документированные для системного вызова stat(2) также применимы и тут.  


◦ TIME
Команда time запускает указанную команду с заданными аргументами. Когда команда завершается, time выводит на стандартный вывод статистическое сообщение об использованном времени при этом запуске. Эта статистика содержит (i) реальное время выполнение между вызовом и завершением, (ii) время CPU, которое занял пользователь (сумма значений tms_utime и tms_cutime в структуре struct tms , которая возвращается вызовом times(2)), и (iii) время CPU занятое системой (сумма значений tms_stime и tms_cstime в структуре struct tms , которая возвращается вызовом times(2)).  
ОПЦИИ
-p
Когда используется локаль POSIX, используется точный традиционный формат
"real %f\nuser %f\nsys %f\n"
(с цифрами в секундах) где число разрядов в выводе для %f не задаётся, но является достаточным для точного выражения времени и по крайней мере разрядов не меньше одного.
КОД ВОЗВРАТА
Если команда была вызвана, то код возврата соответствует тому, который возвращает команда. В противном случае он равен 127, если команда не найдена, 126 если она найдена, но не может быть вызвана и некоторому другому отличному от нуля значению (1-125), если случились какие-либо другие ошибки.  


◦ CTIME
Функции ctime(), gmtime() и localtime() в качестве агрумента используют тип данных time_t , представляющий собой календарное время. Функции интерпретируют его как абсолютное время, содержащее количество секунд, прошедших с 00:00:00 1 января 1970 года времени UTC.
Функции asctime() и mktime() используют в качестве аргумента локальное время в календарном представлении, то есть разделеное на год, месяц, день и т.д. Время в календарном представлении хранится в структуре tm, которая определена в файле <time.h> следующим образом:


struct tm {
        int     tm_sec;         /* секунды */
        int     tm_min;         /* минуты */
        int     tm_hour;        /* часы */
        int     tm_mday;        /* день месяца */
        int     tm_mon;         /* месяц */
        int     tm_year;        /* год */
        int     tm_wday;        /* день недели */
        int     tm_yday;        /* день года */
        int     tm_isdst;       /* летнее время */
};

Члены структуры tm:

tm_sec
Число секунд, прошедших после минуты, обычно в диапазоне от 0 до 59; но для того, чтобы установить високосную секунду, используются числа до 61.
tm_min
Число минут, прошедших после часа, от 0 до 59.
tm_hour
Количество прошедших часов после полуночи, от 0 до 23.
tm_mday
День месяца, от 1 до 31.
tm_mon
Число месяцев, прошедших с января, от 0 до 11.
tm_year
Число лет, прошедших с 1900.
tm_wday
Число дней, прошедших с воскресенья, от 0 до 6.
tm_yday
Количество дней, прошедших с 1 января, от 0 до 365.
tm_isdst
Этот флаг показывает, в действительности ли "летнее" время учтено в этой структуре. Значение флага положительно, если "летнее" время учитывается, 0, если нет, и отрицательно, если информация недоступна.
Функция ctime(t) является эквивалентом asctime(localtime(t)). Она преобразует календарное время t в строку формата

"Wed Jun 30 21:49:08 1993\n"
Аббревиатуры дней недели: `Sun', `Mon', `Tue', `Wed', `Thu', `Fri' и `Sat'. Аббревиатуры месяцев: `Jan', `Feb', `Mar', `Apr', `May', `Jun', `Jul', `Aug', `Sep', `Oct', `Nov' и `Dec'. Возвращаемое значение указывает на статически размещенную строку, которая может быть заново записана с помощью последовательности вызовов любых функций даты и времени. Функция также устанавливает значение внешней переменной tzname (см. tzset(3)) равным значению текущей временной зоны. Реентрантная версия ctime_r() делает то же самое, но заносит строку в буфер, предоставляемый пользователем. Длина буфера должна быть не менее 26 байт. Устанавливать tzname необязательно.

Функция gmtime() преобразует календарное время timep в локальное представление времени, определенное во всеобщем скоординированном времени (UTC). Но она может вернуть значение NULL, если год не может быть описан типом integer. Возвращаемое значение указывает на статически выделенную структуру, содержимое которой может быть перезаписано последующими вызовами любых функций, работающих с датой и временем. Функция gmtime_r() делает то же самое, но помещает данные в структуру, предоставленную пользователем.

Функция localtime() преобразует календарное время timep в локальное, определенное в соответствии с заданной пользователем временной зоной. Функция работает так, как будто она вызывает tzset(3), и устанавливает внешние переменные: tzname в значение текущей временной зоны, timezone в значение разницы в секундах между всеобщим скоординированным временем (UTC) и локальным стандартом времени и daylight в ненулевое значение, если используются стандартные правила "летнего" времени. Возвращаемое значение указывает на статически выделенную структуру, содержимое которой может быть перезаписано последующими вызовами любых функций, работающих с датой и временем. Функция localtime_r() делает то же самое, но помещает данные в структуру, предоставленную пользователем. Она не нуждается в установке tzname.

Функция asctime() преобразует значение локального времени tm в строку того же формата, что и функция ctime(). Возвращаемое значение указывает на статическую строку, которая может быть перезаписана последовательностью вызовов любых функций даты и времени. Функция asctime_r() делает то же самое, но заносит строку в буфер, предоставленный пользователем. Длина буфера должна быть не менее 26 байт.

Функция mktime() преобразует время в календарном представлении в абсолютное время. Функция игнорирует содержимое полей структуры tm_wday и tm_yday и пересчитывает их значения в соответствии с другими элементами структуры. Если значения элементов структуры выходят за пределы допустимых значений, то они "нормализуются" (так, например, 40 октября превращается в 9 ноября). Вызов mktime() также присваивает внешней переменной tzname значение текущей временной зоны. Если локальное время не может быть представлено как календарное (число секунд с начала века), то mktime() возвращает значение (time_t)(-1) и не изменяет значения членов структуры локального времени tm_wday и tm_yday.  

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Все вышеперечисленные функции возвращают описанное значение или NULL (-1 в случае mktime()) при возникновении ошибки.  
ЗАМЕЧАНИЯ


◦ READLINK
Вывести значение символической ссылки на стандартный вывод.
-f, --canonicalize
получить каноническое имя файла путем рекурсивного следования по всем символьным ссылкам в каждом компоненте заданного пути; все компоненты пути, кроме последнего, должны существовать
-e, --canonicalize-existing
получить каноническое имя файла путем рекурсивного следования по всем символьным ссылкам в каждом компоненте заданного пути; все компоненты пути должны существовать
-m, --canonicalize-missing
получить каноническое имя файла путем рекурсивного следования по всем символьным ссылкам в каждом компоненте заданного пути; компоненты пути не обязаны существовать
-n, --no-newline
не выводить завершающий символ новой строки
-q, --quiet,
-s, --silent
подавлять большинство сообщений об ошибках
-v, --verbose
выводить сообщения об ошибках
--help
вывести справку и закончить работу
--version
вывести информацию о версии и закончить работу
readlink помещает содержимое символьной ссылки path в буфер buf длиной bufsiz . readlink не добавляет в buf символ NUL. Если файл, помещаемый в буфер, слишком мал, его длина bufsiz будет урезана.  
ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Этот вызов возвращает количество символов, помещенных в буфер, или (при ошибках) возвращается -1, и переменной errno присваивается номер ошибки.  
НАЙДЕННЫЕ ОШИБКИ
ENOTDIR
Один из компонентов пути не является каталогом.
EINVAL
bufsiz не является положительным числом.
ENAMETOOLONG
Путь или компонент пути слишком длинный.
ENOENT
Указанного файла не существует.
EACCES
Запрещен поиск в каталоге, являющемся компонентом пути.
ELOOP
Слишком много символьных ссылок в указанном имени.
EINVAL
Файл не является символьной ссылкой.
EIO
При чтении данных файловой системы произошла ошибка ввода-вывода.
EFAULT
buf указывает на каталог за пределами доступного адресного пространства.
ENOMEM


◦ PERROR
Процедура perror() выводит в стандартный поток ошибки сообщения, описывая ошибку, произошедшую при последнем системном вызове или вызове библиотечной функции. Сначала (если s не равно NULL и *s не равно NULL) выводится строка s, затем двоеточие, пробел и сообщение, завершающееся переводом строки. Для большего удобства параметы строки должны содержать имя функции, вызвавшей ошибку. Номер ошибки извлекается из внешней переменной errno, которая устанавливается в случае ошибки, но не "очищается" в случае нормального завершения работы. Глобальный список ошибок sys_errlist[], упорядоченный в соответствии с errno, может быть использован для вывода сообщений об ошибке без перевода строки. Наибольший номер в таблице имеет sys_nerr -1. Будьте осторожны при непосредственном использовании этого массива. Новые элементы не могут быть вписаны в sys_errlist[]. Если системный вызов завершается ошибкой, то возвращается -1 и переменная errno устанавливается равной коду ошибки (эти величины могут быть найдены в <errno.h>). Многие системные функции работают именно так. Функция perror() позволяет отображать коды ошибок в понятном человеку виде. Заметьте, что errno не является определенной после нормального завершения системного вызова: этот вызов может изменить переменную кода ошибки, даже если завершился удачно (например, потому, что он использовал другие функции, завершившиеся ошибкой). Таким образом, если за вызовом, завершившимся ошибкой, непосредственно не следует perror, то величина errno должна быть сохранена.  


◦ STRERROR
Функция strerror() возвращает строку, описывающую код ошибки, переданный в аргументе errnum, возможно с учетом категории LC_MESSAGES текущей локали для выбора соответсвующего языка. Приложение не должно изменять строку. Строка может измениться при последующем вызовом perror() или strerror(). В библиотеке нет функций изменяющих эту строку.
Функция strerror_r() аналогична strerror(), но безопасна с точки зрения подпроцессов (threads). Она возвращает строку в буфере buf, предоставленном пользователем и имеющим длину n.

 

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция strerror() возвращает соответсвующее описание ошибки или сообщение о том, что ошибка неизвестна. Значение errno при удачном вызове не меняется, а при ошибке устанавливается в ненулевое значение. Функция strerror_r() возвращает 0 при успешном завершении и -1 при ошибке, устанавливая при этом errno.
 

НАЙДЕННЫЕ ОШИБКИ
EINVAL
Значение errnum не является правильным кодом ошибки.
ERANGE
Предоставлено недостаточно места для размещения строки описания ошибки.

◦ EXIT
Функция exit() приводит к обычному завершению программы, и величина status & 0377 возвращается процессу-родителю (см. wait(2)). Все функции, зарегистрированные с помощью atexit() и on_exit(), вызываются в порядке, обратном порядку регистрации. Все данные всех открытых потоков сохраняются и потоки закрываются. Файлы, созданные функцией tmpfile() удаляются.
Стандарт C описывает два определения EXIT_SUCCESS и EXIT_FAILURE, которые могут быть переданы exit() для обозначения соответственно успешного и неуспешного завершения.  

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ
Функция exit() не возвращает никаких значений.  